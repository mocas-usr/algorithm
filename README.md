# algorithm
数据结构与算法的基本学习代码
./src/数据结构
    包含数据结构的java程序
./src/算法分析
    包含java常用算法的程序
    
    
数据结构
1.avltree 平衡二叉树
    1.1 AVLTreeDemo 
        平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。
        具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。
   
2.binarytree 二叉排序树
    2.1 binarySortTreeDemo.java
        给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加。

3.graph 
    3.1 graphDemo 图
        顶点(vertex)
        边(edge)
        路径
        无向图(右图)

4.hashTable
    4.1 hashTableDemo 哈希表
    

5.huffmancode
    5.1 huffManCodeDemo.java
        赫夫曼编码也翻译为    哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法
        赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。


6.search 查找算法
    6.1 binarySearchDemo  二分查找：
          请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示"没有这个数"。
    6.2 inserValueSearchDemo 插值查找
        插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。
        将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.key 就是前面我们讲的  findVal
    6.3 fibonacciSearchDemo 斐波那契(黄金分割法)查找算法
        斐波那契(黄金分割法)原理:
        斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列），如下图所示
    6.4 seqSearchDemo 线性查找
7.sort 排序数据结构
    7.1 稀疏数组 sparseArray
        当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
    7.2 单向链表 singleLinkedListDemo
        使用带head头的单向链表实现 –水浒英雄排行榜管理
    7.3 doubleLinkedListDemo 双向链表
        使用带head头的双向链表实现 –水浒英雄排行榜
    7.4 josepfu 约瑟夫问题，环形链表
        Josephu(约瑟夫、约瑟夫环)  问题
        Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
    7.5 arrayQueueDemo 队列
        队列是一个有序列表，可以用数组或是链表来实现。
        遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出
    7.6 circleArrayDemo 环形队列
        对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)
    7.7 arrayStackDemo 
    栈的英文为(stack)
    栈是一个先入后出(FILO-First In Last Out)的有序列表。
    7.8 recursionTest 递归
    7.9 sortDemo 冒泡排序
        冒泡排序（Bubble Sorting）的基本思想是：通过对待
        排序序列从前向后（从下标较小的元素开始）,依次比较
        相邻元素的值，若发现逆序则交换，使值较大
        的元素逐渐从前移向后部，就象水底下的气泡一样逐渐
        向上冒。
    7.10 insertSortDemo 插入排序
        插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。
    7.11 shellSortDemo 希尔排序
        希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止
    7.12 quickSortDemo 快速排序
        快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
    7.13 mergeSortDemo 归并排序
        归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
    7.14 radixSortDemo 基数排序
         基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
    7.15 selectSortDemo选择排序
          选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。
 
8.tree
    8.1 binarTree     二叉树-查找指定节点
        要求
        请编写前序查找，中序查找和后序查找的方法。
        并分别使用三种查找方式，查找 heroNO = 5 的节点
        并分析各种查找方式，分别比较了多少次
    8.2 arrBinaryTreeDemo.java 二叉树遍历
    8.3 heapSortDemo 堆排序代码实现
        要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。
        代码实现
     8.4 src/数据结构/tree/huffmantree/huffManTreeDemo  
        给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。
     8.5  src/数据结构/tree/thread/threadBinaryTreeDemo  线索化二叉树
        分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致。



算法分析

1. binarysortDemo
    1.1 binarySearchDemo 二分查找
        二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找

2. dac
    2.1 Hanoitower

3.dijkstra 
    3.1  DijkstraAlgorithm 迪杰斯特拉算法
            战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄
            各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
            问：如何计算出G村庄到 其它各个村庄的最短距离? 
            如果从其它点出发到各个点的最短距离又是多少?

4.divideandcomdemo
    4.1 hanoitower  分治算法，汉诺塔
        如果是有一个盘， A->C
        
        如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘
        
        先把 最上面的盘 A->B
        把最下边的盘 A->C
        把B塔的所有盘 从 B->C   

5.dynamic
    5.1 knapsackproblem 动态规划
        要求达到的目标为装入的背包的总价值最大，并且重量不超出
        要求装入的物品不能重复

6.floyd
    6.1 弗洛伊德(Floyd)算法介绍
        弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。



7.gredy
    7.1 gredyDemo
        假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号

8.horse
    8.1 HorseChessboard 马踏棋盘算法
        马踏棋盘算法也被称为骑士周游问题
        将马随机放在国际象棋的8×8棋盘Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格

9. kmp
    9.1 kmpDemo KMP算法
        字符串匹配问题：：
        有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好""，和一个子串 str2="尚硅谷你尚硅你"
        现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1


10.kruskal
    10.1 KruskalCase 克鲁斯卡尔算法
        某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通
        各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里
        问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?

11.prim
    11.1 primDemo  普里姆算法
        有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通
        各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
        问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?
        思路: 将10条边，连接即可，但是总的里程数不是最小.
        正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少  


12.violenceMatch 
    12.1 violenceMatchDemo 暴力匹配
